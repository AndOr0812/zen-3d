<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>zen3d - custom pass deferred</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
        #info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
			text-align:center;
			color: white;
		}
	</style>
	<script src="../build/zen3d.js"></script>
	<script src="./js/objects/DirectionalLightHelper.js"></script>
	<script src="./js/objects/PointLightHelper.js"></script>
	<script src="./js/objects/SpotLightHelper.js"></script>
	<script src="./js/loaders/AssimpJsonLoader.js"></script>
	<script src="./js/controls/OrbitControls.js"></script>
	<script src="./js/shaders/CopyShader.js"></script>
	<script src="./js/shaders/FXAAShader.js"></script>
	<script src="./js/shaders/DeferredShader.js"></script>
	<script src="./files/dat.gui.min.js"></script>
</head>
<body>

    <div id="info">
        <a href="http://github.com/shawn0326/zen-3d" target="_blank">zen3d</a> - custom pass deferred
    </div>

	<script>

		(function() {
			var width = window.innerWidth || 2;
	        var height = window.innerHeight || 2;

	        var canvas = document.createElement( 'canvas' );
	        canvas.width = width;
	        canvas.height = height;
			document.body.appendChild( canvas );

			var scene = new zen3d.Scene();
			console.log(scene);

			var monkey = "resources/models/assimp/monkey/monkey.json";

			var loader = new zen3d.AssimpJsonLoader();
			loader.load(monkey, function(object) {
				var monkey = object.getObjectByName("Suzanne").children[0];
				monkey.material.diffuse.setRGB(1, 1, 1);
				// monkey.material.specular.setRGB(1, 0, 0);
				monkey.material.emissive.setRGB(0.2, 0, 0);
				monkey.castShadow = true;
				object.scale.set(10, 10, 10);
				object.position.y = 2;
				scene.add(object);
			});

			var material = new zen3d.BasicMaterial();
			material.diffuse.setRGB(0, 1, 1);
			material.transparent = true;
			material.opacity = 0.3;
			var cube = new zen3d.Mesh(new zen3d.CubeGeometry(5, 5, 5), material);
			cube.position.set(20, 0, 0);
			scene.add(cube);

			var plane_geometry = new zen3d.PlaneGeometry(500, 500);
	        var material = new zen3d.LambertMaterial();
			material.diffuse.setHex(0xffffff);
			// material.emissive.setRGB(1, 0, 0);
			// material.specular.setRGB(0, 0, 0);
			var plane = new zen3d.Mesh(plane_geometry, material);
			plane.receiveShadow = true;
	        plane.position.y = -10;
	        scene.add(plane);

			// var ambientLight = new zen3d.AmbientLight();
			// ambientLight.color.setHex(0xffffff);
			// ambientLight.intensity = 0.5;
	        // scene.add(ambientLight);

	        var directionalLight = new zen3d.DirectionalLight();
	        directionalLight.color.setHex(0xffff00);
			directionalLight.position.set(-30, 30, 0);
			directionalLight.intensity = 0.4;
			directionalLight.lookAt(new zen3d.Vector3(), new zen3d.Vector3(0, 1, 0));
			directionalLight.castShadow = true;
			directionalLight.shadow.bias = -0.03;
			directionalLight.shadow.windowSize = 50;
			scene.add(directionalLight);

			var directionalLightHelper = new zen3d.DirectionalLightHelper(directionalLight, 3);
			directionalLight.add(directionalLightHelper);

			var pointLight = new zen3d.PointLight();
			pointLight.position.set(30, 30, 30);
			pointLight.color.setHex(0x00ffff);
			pointLight.decay = 2;
			scene.add(pointLight);

			var pointLightHelper = new zen3d.PointLightHelper(pointLight, 2);
			pointLight.add(pointLightHelper);

			var spotLight = new zen3d.SpotLight();
	        spotLight.color.setHex(0x00ff00);
			spotLight.angle = Math.PI / 6;
			spotLight.position.set(0, 40, -40);
			spotLight.lookAt(new zen3d.Vector3(), new zen3d.Vector3(0, 1, 0));
			spotLight.penumbra = 0.2;
			spotLight.distance = 400;
			spotLight.shadow.bias = -0.003;
			scene.add(spotLight);
			
			var spotLightHelper = new zen3d.SpotLightHelper(spotLight);
			spotLight.add(spotLightHelper);

			var camera = new zen3d.Camera();
	        camera.position.set(30, 50, 100);
	        camera.lookAt(new zen3d.Vector3(0, 0, 0), new zen3d.Vector3(0, 1, 0));
	        camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 500);
	        scene.add(camera);

			var controller = new zen3d.OrbitControls(camera, canvas);

			var backRenderTarget = new zen3d.RenderTargetBack(canvas);

			var normalDepthRenderTarget = new zen3d.RenderTarget2D(width, height);
			normalDepthRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			normalDepthRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			normalDepthRenderTarget.texture.pixelType = zen3d.WEBGL_PIXEL_TYPE.FLOAT;
			normalDepthRenderTarget.texture.generateMipmaps = false;

			var colorRenderTarget = new zen3d.RenderTarget2D(width, height);
			colorRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			colorRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			colorRenderTarget.texture.pixelType = zen3d.WEBGL_PIXEL_TYPE.FLOAT;
			colorRenderTarget.texture.generateMipmaps = false;

			var resultRenderTarget = new zen3d.RenderTarget2D(width, height);
			resultRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.LINEAR;
			resultRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.LINEAR;
			// resultRenderTarget.texture.pixelType = zen3d.WEBGL_PIXEL_TYPE.FLOAT;
			resultRenderTarget.texture.generateMipmaps = false;

			var gl = canvas.getContext("webgl", {
				antialias: true, // antialias
				alpha: false, // effect performance, default false
				// premultipliedAlpha: false, // effect performance, default false
				stencil: true
			});
			var glCore = new zen3d.WebGLCore(gl);

			var shadowMapPass = new zen3d.ShadowMapPass();

			var normalDepthMaterial = new zen3d.ShaderMaterial(
				zen3d.DeferredShader.normalDepth.vertexShader,
				zen3d.DeferredShader.normalDepth.fragmentShader,
				{}
			);

			var normalDepthShininessMaterial = new zen3d.ShaderMaterial(
				zen3d.DeferredShader.normalDepthShininess.vertexShader,
				zen3d.DeferredShader.normalDepthShininess.fragmentShader,
				{}
			);

			var colorMaterial = new zen3d.ShaderMaterial(
				zen3d.DeferredShader.color.vertexShader,
				zen3d.DeferredShader.color.fragmentShader,
				{
					specular: [1, 1, 1],
        			shininess: 30
				}
			);

			var reconstructionMaterial = new zen3d.ShaderMaterial(
				zen3d.DeferredShader.reconstruction.vertexShader,
				zen3d.DeferredShader.reconstruction.fragmentShader,
				{
					samplerLight: null,

					specular: [0, 0, 0],
					shininess: 30,

					viewWidth: 800,
					viewHeight: 600
				}
			);

			var copyPass = new zen3d.ShaderPostPass(zen3d.CopyShader);
			var fxaaPass = new zen3d.ShaderPostPass(zen3d.FXAAShader);

			var emissiveLightPass = new zen3d.ShaderPostPass(zen3d.DeferredShader.emissiveLight);
			emissiveLightPass.material.depthWrite = false;

			var directionalLightPass = new zen3d.ShaderPostPass(zen3d.DeferredShader.directionalLight);
			directionalLightPass.material.transparent = true;
			directionalLightPass.material.blending = zen3d.BLEND_TYPE.ADD;
			directionalLightPass.material.depthWrite = false;
			directionalLightPass.material.depthTest = false;

			var pointLightPass = new zen3d.ShaderPostPass(zen3d.DeferredShader.pointLight);
			pointLightPass.material.transparent = true;
			pointLightPass.material.blending = zen3d.BLEND_TYPE.ADD;
			pointLightPass.material.depthWrite = false;
			pointLightPass.material.depthTest = false;

			var spotLightPass = new zen3d.ShaderPostPass(zen3d.DeferredShader.spotLight);
			spotLightPass.material.transparent = true;
			spotLightPass.material.blending = zen3d.BLEND_TYPE.ADD;
			spotLightPass.material.depthWrite = false;
			spotLightPass.material.depthTest = false;

			var directionalLightPrePass = new zen3d.ShaderPostPass(zen3d.DeferredShader.directionalLightPre);
			directionalLightPrePass.material.transparent = true;
			directionalLightPrePass.material.blending = zen3d.BLEND_TYPE.ADD;
			directionalLightPrePass.material.depthWrite = false;
			directionalLightPrePass.material.depthTest = false;
			directionalLightPrePass.material.premultipliedAlpha = true;

			var pointLightPrePass = new zen3d.ShaderPostPass(zen3d.DeferredShader.pointLightPre);
			pointLightPrePass.material.transparent = true;
			pointLightPrePass.material.blending = zen3d.BLEND_TYPE.ADD;
			pointLightPrePass.material.depthWrite = false;
			pointLightPrePass.material.depthTest = false;
			pointLightPrePass.material.premultipliedAlpha = true;

			var spotLightPrePass = new zen3d.ShaderPostPass(zen3d.DeferredShader.spotLightPre);
			spotLightPrePass.material.transparent = true;
			spotLightPrePass.material.blending = zen3d.BLEND_TYPE.ADD;
			spotLightPrePass.material.depthWrite = false;
			spotLightPrePass.material.depthTest = false;
			spotLightPrePass.material.premultipliedAlpha = true;

			function setLightVisibility() {
				if (params.directionalLight) {
					if (scene.children.indexOf(directionalLight) < 0) {
						scene.add(directionalLight);
					}
				} else {
					scene.remove(directionalLight);
				}
				if(params.pointLight) {
					if (scene.children.indexOf(pointLight) < 0) {
						scene.add(pointLight);
					}
				} else {
					scene.remove(pointLight);
				}
				if(params.spotLight) {
					if (scene.children.indexOf(spotLight) < 0) {
						scene.add(spotLight);
					}
				} else {
					scene.remove(spotLight);
				}
			}

			// gui
			var params = {render: "prelight-deferred", pass: "result", fxaa: true, directionalLight: true, pointLight: true, spotLight: true};
			var gui = new dat.GUI();
			gui.add(params, "render", ["forward", "deferred", "prelight-deferred"]);
			gui.add(params, "pass", ["normalDepth(Shininess)", "color(light)", "result"]);
			gui.add(params, "fxaa");
			var lightFolder = gui.addFolder("lights");
			lightFolder.add(params, "directionalLight").onChange(setLightVisibility);
			lightFolder.add(params, "pointLight").onChange(setLightVisibility);
			lightFolder.add(params, "spotLight").onChange(setLightVisibility);
			lightFolder.open();

			setLightVisibility();

			var direction = new zen3d.Vector3();
			var matProjViewInverse = new zen3d.Matrix4();
			var cameraPos = new zen3d.Vector3();

	        function loop(count) {

				requestAnimationFrame(loop);

				controller.update();

				directionalLightHelper.update();
				pointLightHelper.update();
				spotLightHelper.update();

				// do render pass
				scene.updateMatrix();
				scene.updateLights();

				var renderList = scene.updateRenderList(camera);

				shadowMapPass.render(glCore, scene);

				if ( params.render === "forward" ) {

					glCore.texture.setRenderTarget(backRenderTarget);

					glCore.state.clearColor(0, 0, 0, 1);
					glCore.clear(true, true, true);

					glCore.renderPass(renderList.opaque, camera, {
						scene: scene
					});

					glCore.renderPass(renderList.transparent, camera, {
						scene: scene
					});

				} else {

					// render normalDepth texture

					glCore.texture.setRenderTarget(normalDepthRenderTarget);

					glCore.state.clearColor(0, 0, 0, 0);
					glCore.clear(true, true, true);

					glCore.renderPass(renderList.opaque, camera, {
						scene: scene,
						getMaterial: function(renderable) {

							if (params.render == "prelight-deferred") {

								if(!renderable.geometry.attributes["a_Normal"]) {
									normalDepthShininessMaterial.shading = zen3d.SHADING_TYPE.FLAT_SHADING;
								} else {
									normalDepthShininessMaterial.shading = zen3d.SHADING_TYPE.SMOOTH_SHADING;
								}
								if(renderable.material.shininess !== undefined) {
									normalDepthShininessMaterial.uniforms["shininess"] = renderable.material.shininess;
								} else {
									normalDepthShininessMaterial.uniforms["shininess"] = 30;
								}
								return normalDepthShininessMaterial;

							} else {

								if(!renderable.geometry.attributes["a_Normal"]) {
									normalDepthMaterial.shading = zen3d.SHADING_TYPE.FLAT_SHADING;
								} else {
									normalDepthMaterial.shading = zen3d.SHADING_TYPE.SMOOTH_SHADING;
								}
								return normalDepthMaterial;

							}
							
						},
						ifRender: function(renderable) {
							// todo support more object type
							if (renderable.object.material.type == zen3d.MATERIAL_TYPE.LINE) {
								return false;
							}
							return renderable.object.type == zen3d.OBJECT_TYPE.MESH || renderable.object.type == zen3d.OBJECT_TYPE.SKINNED_MESH;
						}
					});

					if(params.render == "deferred") {

						// render color texture

						glCore.texture.setRenderTarget(colorRenderTarget);

						glCore.state.clearColor(0, 0, 0, 0);
						glCore.clear(true, true, true);

						glCore.renderPass(renderList.opaque, camera, {
							scene: scene,
							getMaterial: function(renderable) {
								colorMaterial.diffuse.copy(renderable.material.diffuse);
								colorMaterial.diffuseMap = renderable.material.diffuseMap;
								colorMaterial.emissive.copy(renderable.material.emissive);
								
								if(renderable.material.specular !== undefined) {
									colorMaterial.uniforms["specular"][0] = renderable.material.specular.r;
									colorMaterial.uniforms["specular"][1] = renderable.material.specular.g;
									colorMaterial.uniforms["specular"][2] = renderable.material.specular.b;
								} else {
									colorMaterial.uniforms["specular"][0] = 0;
									colorMaterial.uniforms["specular"][1] = 0;
									colorMaterial.uniforms["specular"][2] = 0;
								}
								
								if(renderable.material.shininess !== undefined) {
									colorMaterial.uniforms["shininess"] = renderable.material.shininess;
								} else {
									colorMaterial.uniforms["shininess"] = 30;
								}
								
								return colorMaterial;
							},
							ifRender: function(renderable) {
								// todo support more object type
								if (renderable.object.material.type == zen3d.MATERIAL_TYPE.LINE) {
									return false;
								}
								return renderable.object.type == zen3d.OBJECT_TYPE.MESH || renderable.object.type == zen3d.OBJECT_TYPE.SKINNED_MESH;
							}
						});

					}


					if (params.render == "deferred") {

						// render emissive light

						glCore.texture.setRenderTarget(resultRenderTarget);

						glCore.state.clearColor(0, 0, 0, 0);
						glCore.clear(true, true, true);

						emissiveLightPass.uniforms["samplerColor"] = colorRenderTarget.texture;
						emissiveLightPass.uniforms["viewWidth"] = width;
						emissiveLightPass.uniforms["viewHeight"] = height;
						emissiveLightPass.render(glCore);

					}
					

					// todo support ambient light

					// render lights

					if (params.render == "prelight-deferred") {

						glCore.texture.setRenderTarget(colorRenderTarget);

						glCore.state.clearColor(0, 0, 0, 0);
						glCore.clear(true, true, true);

					}

					matProjViewInverse.multiplyMatrices(camera.projectionMatrix, camera.viewMatrix).inverse();
					cameraPos.setFromMatrixPosition(camera.worldMatrix);

					// directional
					var pass = params.render == "prelight-deferred" ? directionalLightPrePass : directionalLightPass;
					if (params.render !== "prelight-deferred") {
						pass.uniforms["samplerNormalDepth"] = normalDepthRenderTarget.texture;
						pass.uniforms["samplerColor"] = colorRenderTarget.texture;
					} else {
						pass.uniforms["samplerNormalDepthShininess"] = normalDepthRenderTarget.texture;
					}
					pass.uniforms["viewWidth"] = width;
					pass.uniforms["viewHeight"] = height;
					pass.uniforms["matProjViewInverse"].set(matProjViewInverse.elements);
					pass.uniforms["cameraPos"] = [cameraPos.x, cameraPos.y, cameraPos.z];

					var directionalLights = scene.lights.directional;
					var directsNum = scene.lights.directsNum;

					for (var i = 0; i < directsNum; i++) {

						var directionalLight = directionalLights[i];

						pass.uniforms["lightColor"] = [directionalLight.color[0], directionalLight.color[1], directionalLight.color[2]];
						pass.uniforms["lightDirectionVS"] = [-directionalLight.direction[0], -directionalLight.direction[1], -directionalLight.direction[2]];

						if(directionalLight.shadow) {
							pass.material.defines["SHADOW"] = 1;
							pass.uniforms["shadowBias"] = directionalLight.shadowBias;
							pass.uniforms["shadowRadius"] = directionalLight.shadowRadius;
							pass.uniforms["shadowMapSize"][0] = directionalLight.shadowMapSize[0];
							pass.uniforms["shadowMapSize"][1] = directionalLight.shadowMapSize[1];

							pass.uniforms["shadowMap"] = scene.lights.directionalShadowMap[i];
							pass.uniforms["shadowMatrix"].set(scene.lights.directionalShadowMatrix, i * 16);
						} else {
							pass.material.defines["SHADOW"] = 0;
						}

						pass.render(glCore);

					}

					// point
					var pass = params.render == "prelight-deferred" ? pointLightPrePass : pointLightPass;
					if (params.render !== "prelight-deferred") {
						pass.uniforms["samplerNormalDepth"] = normalDepthRenderTarget.texture;
						pass.uniforms["samplerColor"] = colorRenderTarget.texture;
					} else {
						pass.uniforms["samplerNormalDepthShininess"] = normalDepthRenderTarget.texture;
					}
					pass.uniforms["viewWidth"] = width;
					pass.uniforms["viewHeight"] = height;
					pass.uniforms["matProjViewInverse"].set(matProjViewInverse.elements);
					pass.uniforms["cameraPos"] = [cameraPos.x, cameraPos.y, cameraPos.z];

					var pointLights = scene.lights.point;
					var pointsNum = scene.lights.pointsNum;

					for (var i = 0; i < pointsNum; i++) {

						var pointLight = pointLights[i];

						pass.uniforms["lightColor"] = [pointLight.color[0], pointLight.color[1], pointLight.color[2]];
						pass.uniforms["lightPositionVS"] = [pointLight.position[0], pointLight.position[1], pointLight.position[2]];
						pass.uniforms["lightRadius"] = pointLight.distance;
						pass.uniforms["lightDecay"] = pointLight.decay;

						pass.render(glCore);

					}

					// spot lights
					var pass = params.render == "prelight-deferred" ? spotLightPrePass : spotLightPass;
					if (params.render !== "prelight-deferred") {
						pass.uniforms["samplerNormalDepth"] = normalDepthRenderTarget.texture;
						pass.uniforms["samplerColor"] = colorRenderTarget.texture;
					} else {
						pass.uniforms["samplerNormalDepthShininess"] = normalDepthRenderTarget.texture;
					}
					pass.uniforms["viewWidth"] = width;
					pass.uniforms["viewHeight"] = height;
					pass.uniforms["matProjViewInverse"].set(matProjViewInverse.elements);
					pass.uniforms["cameraPos"] = [cameraPos.x, cameraPos.y, cameraPos.z];

					var spotLights = scene.lights.spot;
					var spotsNum = scene.lights.spotsNum;

					for (var i = 0; i < spotsNum; i++) {

						var spotLight = spotLights[i];

						pass.uniforms["lightColor"] = [spotLight.color[0], spotLight.color[1], spotLight.color[2]];
						pass.uniforms["lightPositionVS"] = [spotLight.position[0], spotLight.position[1], spotLight.position[2]];
						pass.uniforms["lightDirectionVS"] = [-spotLight.direction[0], -spotLight.direction[1], -spotLight.direction[2]];
						pass.uniforms["lightConeCos"] = spotLight.coneCos;
						pass.uniforms["lightPenumbraCos"] = spotLight.penumbraCos;
						pass.uniforms["lightRadius"] = spotLight.distance;
						pass.uniforms["lightDecay"] = spotLight.decay;

						pass.render(glCore);

					}

					if (params.render == "prelight-deferred") {

						// reconstruction

						glCore.texture.setRenderTarget(resultRenderTarget);

						glCore.state.clearColor(0, 0, 0, 1);
						glCore.clear(true, true, true);

						reconstructionMaterial.uniforms["viewWidth"] = width;
						reconstructionMaterial.uniforms["viewHeight"] = height;
						reconstructionMaterial.uniforms["samplerLight"] = colorRenderTarget.texture;
						glCore.renderPass(renderList.opaque, camera, {
							scene: scene,
							getMaterial: function(renderable) {
								if (renderable.material.acceptLight) {
									reconstructionMaterial.diffuse.copy(renderable.material.diffuse);
									reconstructionMaterial.diffuseMap = renderable.material.diffuseMap;
									reconstructionMaterial.emissive.copy(renderable.material.emissive);
									
									if(renderable.material.specular !== undefined) {
										reconstructionMaterial.uniforms["specular"][0] = renderable.material.specular.r;
										reconstructionMaterial.uniforms["specular"][1] = renderable.material.specular.g;
										reconstructionMaterial.uniforms["specular"][2] = renderable.material.specular.b;
									} else {
										reconstructionMaterial.uniforms["specular"][0] = 0;
										reconstructionMaterial.uniforms["specular"][1] = 0;
										reconstructionMaterial.uniforms["specular"][2] = 0;
									}
									
									if(renderable.material.shininess !== undefined) {
										reconstructionMaterial.uniforms["shininess"] = renderable.material.shininess;
									} else {
										reconstructionMaterial.uniforms["shininess"] = 30;
									}
									
									return reconstructionMaterial;
								} else {
									return renderable.material;
								}
							}
						});

					}

					// prelight-deferred support transparent objects
					if (params.render == "prelight-deferred") {

						// render transparent objects forward
						glCore.renderPass(renderList.transparent, camera, {
							scene: scene
						});

					}

					// output

					glCore.texture.setRenderTarget(backRenderTarget);

					glCore.state.clearColor(0, 0, 0, 1);
					glCore.clear(true, true, true);

					var pass = params.fxaa ? fxaaPass : copyPass;

					if ( params.pass === "normalDepth(Shininess)" ) {
						pass.uniforms["tDiffuse"] = normalDepthRenderTarget.texture;
					} else if ( params.pass === "color(light)" ) {
						pass.uniforms["tDiffuse"] = colorRenderTarget.texture;
					} else if ( params.pass === "result" ) {
						pass.uniforms["tDiffuse"] = resultRenderTarget.texture;
					}

					fxaaPass.uniforms["resolution"] = [1 / width, 1 / height];
					
					pass.render(glCore);

				}

	        }

	        loop(0);

			function onWindowResize() {
				width = window.innerWidth || 2;
		        height = window.innerHeight || 2;

				camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 500);

				backRenderTarget.resize(width, height);
				normalDepthRenderTarget.resize(width, height);
				colorRenderTarget.resize(width, height);
				resultRenderTarget.resize(width, height);
			}
			window.addEventListener("resize", onWindowResize, false);
		})();
	</script>
</body>
</html>