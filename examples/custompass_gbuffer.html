<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>zen3d - custom pass gbuffer</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
        #info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
			text-align:center;
			color: white;
		}
	</style>
	<script src="../build/zen3d.js"></script>
	<script src="./js/loaders/AssimpJsonLoader.js"></script>
	<script src="./js/controls/OrbitControls.js"></script>
	<script src="./js/shaders/CopyShader.js"></script>
	<script src="./js/shaders/FXAAShader.js"></script>
	<script src="./js/shaders/DeferredShader.js"></script>
	<script src="./files/dat.gui.min.js"></script>
</head>
<body>

    <div id="info">
        <a href="http://github.com/shawn0326/zen-3d" target="_blank">zen3d</a> - custom pass gbuffer
    </div>

	<script>

		(function() {
			var width = window.innerWidth || 2;
	        var height = window.innerHeight || 2;

	        var canvas = document.createElement( 'canvas' );
	        canvas.width = width;
	        canvas.height = height;
			document.body.appendChild( canvas );

			var scene = new zen3d.Scene();

			var monkey = "resources/models/assimp/monkey/monkey.json";

			var loader = new zen3d.AssimpJsonLoader();
			loader.load(monkey, function(object) {
				var monkey = object.getObjectByName("Suzanne").children[0];
				monkey.material.diffuse.setRGB(1, 1, 1);
				// monkey.material.specular.setRGB(1, 0, 0);
				monkey.material.emissive.setRGB(0.1, 0, 0);
				object.scale.set(10, 10, 10);
				object.position.y = 2;
				scene.add(object);
			});

			var plane_geometry = new zen3d.PlaneGeometry(500, 500);
	        var material = new zen3d.PhongMaterial();
			material.diffuse.setHex(0xffffff);
			// material.emissive.setRGB(1, 0, 0);
			// material.specular.setRGB(0, 0, 0);
	        var plane = new zen3d.Mesh(plane_geometry, material);
	        plane.position.y = -10;
	        scene.add(plane);

			// var ambientLight = new zen3d.AmbientLight();
			// ambientLight.color.setHex(0xffffff);
			// ambientLight.intensity = 0.5;
	        // scene.add(ambientLight);

	        var directionalLight = new zen3d.DirectionalLight();
			directionalLight.intensity = 0.8;
	        directionalLight.color.setHex(0xffffff);
			directionalLight.position.set(-30, 30, 0);
			directionalLight.lookAt(new zen3d.Vector3(), new zen3d.Vector3(0, 1, 0));
			scene.add(directionalLight);

			var pointLight = new zen3d.PointLight();
			pointLight.position.set(10, 30, 10);
			pointLight.color.setHex(0x00ffff);
			pointLight.decay = 2; 
			pointLight.distance = 300;
			scene.add(pointLight);

			var camera = new zen3d.Camera();
	        camera.position.set(30, 50, 100);
	        camera.lookAt(new zen3d.Vector3(0, 0, 0), new zen3d.Vector3(0, 1, 0));
	        camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 500);
	        scene.add(camera);

			var controller = new zen3d.OrbitControls(camera, canvas);

			var backRenderTarget = new zen3d.RenderTargetBack(canvas);

			var normalDepthRenderTarget = new zen3d.RenderTarget2D(width, height);
			normalDepthRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			normalDepthRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			normalDepthRenderTarget.texture.pixelType = zen3d.WEBGL_PIXEL_TYPE.FLOAT;
			normalDepthRenderTarget.texture.generateMipmaps = false;

			var colorRenderTarget = new zen3d.RenderTarget2D(width, height);
			colorRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			colorRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			colorRenderTarget.texture.pixelType = zen3d.WEBGL_PIXEL_TYPE.FLOAT;
			colorRenderTarget.texture.generateMipmaps = false;

			var emissiveRenderTarget = new zen3d.RenderTarget2D(width, height);
			emissiveRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			emissiveRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			emissiveRenderTarget.texture.pixelType = zen3d.WEBGL_PIXEL_TYPE.FLOAT;
			emissiveRenderTarget.texture.generateMipmaps = false;

			var directionalLightRenderTarget = new zen3d.RenderTarget2D(width, height);
			directionalLightRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			directionalLightRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.NEAREST;
			directionalLightRenderTarget.texture.pixelType = zen3d.WEBGL_PIXEL_TYPE.FLOAT;
			directionalLightRenderTarget.texture.generateMipmaps = false;

			var resultRenderTarget = new zen3d.RenderTarget2D(width, height);
			resultRenderTarget.texture.minFilter = zen3d.WEBGL_TEXTURE_FILTER.LINEAR;
			resultRenderTarget.texture.magFilter = zen3d.WEBGL_TEXTURE_FILTER.LINEAR;
			resultRenderTarget.texture.generateMipmaps = false;

			var gl = canvas.getContext("webgl", {
				antialias: true, // antialias
				alpha: false, // effect performance, default false
				// premultipliedAlpha: false, // effect performance, default false
				stencil: true
			});
			var glCore = new zen3d.WebGLCore(gl);

			var shadowMapPass = new zen3d.ShadowMapPass();

			var normalDepthMaterial = new zen3d.ShaderMaterial(
				zen3d.DeferredShader.normalDepth.vertexShader,
				zen3d.DeferredShader.normalDepth.fragmentShader,
				{}
			);

			var colorMaterial = new zen3d.ShaderMaterial(
				zen3d.DeferredShader.color.vertexShader,
				zen3d.DeferredShader.color.fragmentShader,
				{
					specular: [1, 1, 1],
        			shininess: 30
				}
			);

			var copyPass = new zen3d.ShaderPostPass(zen3d.CopyShader);
			var fxaaPass = new zen3d.ShaderPostPass(zen3d.FXAAShader);

			var emissiveLightPass = new zen3d.ShaderPostPass(zen3d.DeferredShader.emissiveLight);
			emissiveLightPass.material.depthWrite = false;

			var directionalLightPass = new zen3d.ShaderPostPass(zen3d.DeferredShader.directionalLight);
			directionalLightPass.material.transparent = true;
			directionalLightPass.material.blending = zen3d.BLEND_TYPE.ADD;
			directionalLightPass.material.depthWrite = false;
			directionalLightPass.material.depthTest = false;

			var pointLightPass = new zen3d.ShaderPostPass(zen3d.DeferredShader.pointLight);
			pointLightPass.material.transparent = true;
			pointLightPass.material.blending = zen3d.BLEND_TYPE.ADD;
			pointLightPass.material.depthWrite = false;
			pointLightPass.material.depthTest = false;

			// gui
			var params = {type: "FORWARD", fxaa: true};
			var gui = new dat.GUI();
			gui.add(params, "type", ["FORWARD", "DEFERRED", "NORMAL", "COLOR", "EMISSIVE"]);
			gui.add(params, "fxaa");

			var direction = new zen3d.Vector3();
			var matProjViewInverse = new zen3d.Matrix4();
			var cameraPos = new zen3d.Vector3();

	        function loop(count) {

				requestAnimationFrame(loop);

				controller.update();

				// do render pass
				scene.updateMatrix();
				scene.updateLights();

				var renderList = scene.updateRenderList(camera);

				if ( params.type === "FORWARD" ) {

					shadowMapPass.render(glCore, scene);

					glCore.texture.setRenderTarget(backRenderTarget);

					glCore.state.clearColor(0, 0, 0, 1);
					glCore.clear(true, true, true);

					glCore.renderPass(renderList.opaque, camera, {
						scene: scene,
						getMaterial: function(renderable) {
							return scene.overrideMaterial || renderable.material;
						}
					});

				} else {

					// render normalDepth texture

					glCore.texture.setRenderTarget(normalDepthRenderTarget);

					glCore.state.clearColor(0, 0, 0, 0);
					glCore.clear(true, true, true);

					glCore.renderPass(renderList.opaque, camera, {
						scene: scene,
						getMaterial: function(renderable) {
							return normalDepthMaterial;
						}
					});

					// render color texture

					glCore.texture.setRenderTarget(colorRenderTarget);

					glCore.state.clearColor(0, 0, 0, 0);
					glCore.clear(true, true, true);

					glCore.renderPass(renderList.opaque, camera, {
						scene: scene,
						getMaterial: function(renderable) {
							colorMaterial.diffuse.copy(renderable.material.diffuse);
							colorMaterial.diffuseMap = renderable.material.diffuseMap;
							colorMaterial.emissive.copy(renderable.material.emissive);
							
							if(renderable.material.specular !== undefined) {
								colorMaterial.uniforms["specular"][0] = renderable.material.specular.r;
								colorMaterial.uniforms["specular"][1] = renderable.material.specular.g;
								colorMaterial.uniforms["specular"][2] = renderable.material.specular.b;
							} else {
								colorMaterial.uniforms["specular"][0] = 0;
								colorMaterial.uniforms["specular"][1] = 0;
								colorMaterial.uniforms["specular"][2] = 0;
							}
							
							if(renderable.material.shininess !== undefined) {
								colorMaterial.uniforms["shininess"] = renderable.material.shininess;
							} else {
								colorMaterial.uniforms["shininess"] = 30;
							}
							
							return colorMaterial;
						}
					});

					// render emissive light

					glCore.texture.setRenderTarget(resultRenderTarget);

					glCore.state.clearColor(0, 0, 0, 0);
					glCore.clear(true, true, true);

					emissiveLightPass.uniforms["samplerColor"] = colorRenderTarget.texture;
					emissiveLightPass.uniforms["viewWidth"] = width;
					emissiveLightPass.uniforms["viewHeight"] = height;
					emissiveLightPass.render(glCore);

					// todo support ambient light

					// render lights

					if(params.type === "DEFERRED") {

						glCore.texture.setRenderTarget(resultRenderTarget);

						// glCore.state.clearColor(0, 0, 0, 0);
						// glCore.clear(true, true, true);

						// directional
						directionalLightPass.uniforms["samplerNormalDepth"] = normalDepthRenderTarget.texture;
						directionalLightPass.uniforms["samplerColor"] = colorRenderTarget.texture;
						directionalLightPass.uniforms["viewWidth"] = width;
						directionalLightPass.uniforms["viewHeight"] = height;
						matProjViewInverse.multiplyMatrices(camera.projectionMatrix, camera.viewMatrix).inverse();
						directionalLightPass.uniforms["matProjViewInverse"].set(matProjViewInverse.elements);
						cameraPos.setFromMatrixPosition(camera.worldMatrix);
						directionalLightPass.uniforms["cameraPos"] = [cameraPos.x, cameraPos.y, cameraPos.z];

						var directionalLights = scene.lights.directional;

						for (var i = 0; i < directionalLights.length; i++) {

							var directionalLight = directionalLights[i];

							directionalLightPass.uniforms["lightColor"] = [directionalLight.color[0], directionalLight.color[1], directionalLight.color[2]];
							directionalLightPass.uniforms["lightDirectionVS"] = [-directionalLight.direction[0], -directionalLight.direction[1], -directionalLight.direction[2]];

							directionalLightPass.render(glCore);

						}

						// point
						// TODO unknow error
						pointLightPass.uniforms["samplerNormalDepth"] = normalDepthRenderTarget.texture;
						pointLightPass.uniforms["samplerColor"] = colorRenderTarget.texture;
						pointLightPass.uniforms["viewWidth"] = width;
						pointLightPass.uniforms["viewHeight"] = height;
						matProjViewInverse.multiplyMatrices(camera.projectionMatrix, camera.viewMatrix).inverse();
						pointLightPass.uniforms["matProjViewInverse"].set(matProjViewInverse.elements);
						cameraPos.setFromMatrixPosition(camera.worldMatrix);
						pointLightPass.uniforms["cameraPos"] = [cameraPos.x, cameraPos.y, cameraPos.z];

						var pointLights = scene.lights.point;

						for (var i = 0; i < pointLights.length; i++) {

							var pointLight = pointLights[i];

							pointLightPass.uniforms["lightColor"] = [pointLight.color[0], pointLight.color[1], pointLight.color[2]];
							pointLightPass.uniforms["lightPositionVS"] = [pointLight.position[0], pointLight.position[1], pointLight.position[2]];
							pointLightPass.uniforms["lightRadius"] = pointLight.distance;

							pointLightPass.render(glCore);

						}

						// todo support spot lights

					}

					// output

					glCore.texture.setRenderTarget(backRenderTarget);

					glCore.state.clearColor(0, 0, 0, 1);
					glCore.clear(true, true, true);

					var pass = params.fxaa ? fxaaPass : copyPass;

					if ( params.type === "NORMAL" ) {
						pass.uniforms["tDiffuse"] = normalDepthRenderTarget.texture;
					} else if ( params.type === "COLOR" ) {
						pass.uniforms["tDiffuse"] = colorRenderTarget.texture;
					} else if ( params.type === "EMISSIVE" ) {
						pass.uniforms["tDiffuse"] = resultRenderTarget.texture;
					} else if ( params.type === "DEFERRED" ) {
						pass.uniforms["tDiffuse"] = resultRenderTarget.texture;
					}

					fxaaPass.uniforms["resolution"] = [1 / width, 1 / height];
					
					pass.render(glCore);

				}
				
				// switch (params.type) {
				// 	case "FORWARD":
				// 		glCore.renderPass(renderList.opaque, camera, {
				// 			scene: scene,
				// 			getMaterial: function(renderable) {
				// 				return scene.overrideMaterial || renderable.material;
				// 			}
				// 		});
				// 		break;
				// 	case "NORMAL":
				// 		glCore.renderPass(renderList.opaque, camera, {
				// 			scene: scene,
				// 			getMaterial: function(renderable) {
				// 				return normalDepthMaterial;
				// 			}
				// 		});
				// 		break;
				// 	case "COLOR":
				// 		glCore.renderPass(renderList.opaque, camera, {
				// 			scene: scene,
				// 			getMaterial: function(renderable) {
				// 				colorMaterial.diffuse.copy(renderable.material.diffuse);
				// 				colorMaterial.diffuseMap = renderable.material.diffuseMap;
				// 				colorMaterial.emissive.copy(renderable.material.emissive);
								
				// 				if(renderable.material.specular !== undefined) {
				// 					colorMaterial.uniforms["specular"][0] = renderable.material.specular.r;
				// 					colorMaterial.uniforms["specular"][1] = renderable.material.specular.g;
				// 					colorMaterial.uniforms["specular"][2] = renderable.material.specular.b;
				// 				} else {
				// 					colorMaterial.uniforms["specular"][0] = 1;
				// 					colorMaterial.uniforms["specular"][1] = 1;
				// 					colorMaterial.uniforms["specular"][2] = 1;
				// 				}
								
				// 				if(renderable.material.shininess !== undefined) {
				// 					colorMaterial.uniforms["shininess"] = colorMaterial.shininess;
				// 				} else {
				// 					colorMaterial.uniforms["shininess"] = 30;
				// 				}
								
				// 				return colorMaterial;
				// 			}
				// 		});
				// 		break;
				// 	case "EMISSIVE":
				// 		break;
				// }
				

	        }

	        loop(0);

			function onWindowResize() {
				width = window.innerWidth || 2;
		        height = window.innerHeight || 2;

				camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 500);

				backRenderTarget.resize(width, height);
			}
			window.addEventListener("resize", onWindowResize, false);
		})();
	</script>
</body>
</html>